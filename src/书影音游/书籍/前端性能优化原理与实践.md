# 前端性能优化原理与实践

## 网络篇

### http优化方向

#### 减少请求次数

#### 减少单次请求时间

#### 以上两点优化：资源压缩与合并
需要与构建工具来完成：webpack

### webpack与gzip

#### webpack

##### 构建过程太花时间

###### 不要让loader做太多事情

###### happypack-将loader由单进程转为多进程

##### 打包体积太大

###### 按需加载

###### gzip

### 图片优化

#### 大图用jpg格式

#### 小图标转为base64

#### 雪碧图

#### webp

### cdn

#### 提升首次请求的响应能力

#### 往往被用来存放静态资源

##### js/css不需要业务服务器进行计算即得的资源

#### 核心点

##### 缓存

###### 把资源copy一份到cdn服务器上

##### 回源

###### cdn发现自己没有这个资源（缓存的数据过期），向上层服务器去要这个资源

## 存储篇

### 缓存

#### 强缓存

##### Expires

###### 是一个时间戳

###### 请求时，如果本地时间小于expires设定的过期时间，那么就直接从缓存中取这个资源。

###### 缺点：本地时间与服务器时间会有时差

##### Cache-Control

###### 有max-age属性

   * 是一个时间长度

   * 是一个相对时间，有能力规避掉expires带来的时差问题

   * 在时间长度范围内都是有效的

###### 记录请求到资源的时间点，以此作为相对时间的起点。确保两个时间点都源于客户端

###### 优先级比expires高

##### 强缓存中，当请求再次发出时，浏览器会根据其中的Expires和Cache-Control判断目标资源是否命中强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信

##### no-cache

###### 绕开浏览器，每次请求都向服务端去确认该资源是否过期

##### no-store

###### 不使用任何缓存策略，连服务端的缓存也会绕开，直接发送请求，下载完整的响应。

#### 协商缓存

##### 浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求，下载完整响应还是从本地获取缓存资源。

##### 如果状态是Not Modified，资源会被重定向到浏览器缓存。状态码是304

##### Last-Modidied

###### 是一个时间戳

###### 如果启用了协商缓存，首次请求时随着Response Headers返回

###### 随后每次请求时，会带上if-Modified-Since的时间戳字段，值是上次response返回的last-modified值

###### 缺点：编辑了文件，文件内容没变，会重新请求资源
修改文件速度过快时，感知不到文件改动

##### Etag

###### 是一个唯一的标识字符串-基于文件内容编码

###### 只要文件内容不同，对应的Etag就是不同的

#### 使用顺序

##### 如果资源不可复用，直接为Cache-Control设置no-store

##### 如果每次都需要向服务器进行缓存有效确认，设置Cache-Control为no-cache

##### 如果该资源可以被代理服务器缓存，设置private。否则设置public

##### 考虑资源的过期时间，设置对应的max-age和s-maxage

##### 配置协商缓存要用到的Etag、last-Modified

### 本地存储

#### cookie

##### cookie的本职工作并非本地存储，而是“维持状态”

##### 存储在浏览器里的小文本文件，附着在http请求上

###### 可以携带用户信息

##### 以键值对形式存在

##### 缺点

###### 不够大

###### 
过量的cookie会带来巨大的性能浪费

   * cookie是紧跟域名的

   * 同一个域名下的所有请求，都会携带cookie

      * 请求一个css或者图片，也会携带cookie

#### web storage

##### local storage

###### 持久化的本地存储

###### 存储在其中的数据永远不会过期

   * 使其消失的唯一办法是手动删除

##### session storage

###### 临时性的本地存储

   * 当会话结束（浏览器被关闭）时，存储的内容也随之释放

##### 特性

###### 存储容量大

###### 仅位于浏览器端，不与服务端发生通信

#### IndexedDB

##### 运行在浏览器上的非关系型数据库

##### 不仅可以存储字符串，还可以存储二进制数据

## 渲染篇

### 服务端渲染

#### 运行机制

##### 客户端渲染

###### 页面上呈现的内容，在html源文件里找不到

###### 流程

   * 服务端把渲染需要的静态文件发送给客户端

   * 客户端请求到之后，在浏览器里跑一遍js

   * 根据js运行结果，生成相应dom

##### 服务端渲染

###### 页面上呈现的内容，在html源文件里可以找到

###### 流程

   * 第一次请求页面时，由服务器把需要的组件或页面渲染成html字符串，然后返回给客户端

   * 客户端拿到手的，是可以直接渲染然后呈现给用户的html内容，不需要为了生成dom内容自己再去跑一遍js

#### 解决的问题

##### 很多网站是出于效益才启用服务端渲染，性能倒在其次

##### seo

###### 搜索引擎搜不到js加载出来的关键字

##### 首屏加载速度过慢

###### 可以直接拿到可以呈现的网页给用户，中间环节在服务端做掉

#### 应用场景

##### 服务端渲染本质是本该浏览器做的事情，分担给服务器去做

### 浏览器渲染机制

#### 渲染过程

##### 什么是

###### 渲染引擎根据html文件描述构建相应的数学模型，调用浏览器各个零部件，将网页资源代码转换为图像结果

###### 流程

   * 

##### 关注点

###### html解释器

   * 将html文档经过词法分析输出dom树

###### css解释器

   * 解析css文档，生成样式规则

###### 图层布局计算模块

   * 布局计算每个对象的精确位置和大小

###### 视图绘制模块

   * 进行具体节点的图像绘制，将像素渲染到屏幕上

###### js引擎

   * 编译执行js代码

##### 阶段

###### 

###### 首先基于html构建一个dom树，dom树与css解释器解析出的cssom相结合，组成了布局渲染树。
浏览器以布局渲染树为蓝本，去计算布局并绘制图像，初次渲染就成功了

###### 之后每当一个新元素加入到dom中，浏览器便会通过css引擎查遍css样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新绘制他

##### css优化

###### 避免使用通配符，只对需要用到的元素进行选择

###### 关注可以通过继承实现的属性，避免重复定义

###### 少用标签选择器，可用类选择器替代
css选择器是从右到左进行匹配的

###### 减少嵌套，后代选择器是开销最高的

##### css与js加载顺序优化

###### html、css、js都具有阻塞渲染的特性

###### css

   * 浏览器在构建cssom的过程中，不会渲染任何已处理的内容
即便dom解析完毕了，只要cssom不ok，渲染这个事情就不ok

   * css需要尽早的下载到客户端，以便缩短首次渲染时间

###### js

   * 首次渲染过程中，js并不是一个非登场不可的角色

   * js的作用在于修改
修改dom和样式

   * js的执行会阻止cssom和dom

      * js引擎是独立于渲染引擎存在的
在何处插入，就在何处执行

      * 当html解析器遇到script标签时，会暂停渲染过程，将控制权交给js引擎

      * js引擎对内联的js代码会直接执行，对外部js文件要先获取到文件，再进行执行。

      * js运行完毕，浏览器又会把控制权还给渲染引擎，继续cssom和dom的构建

      * 与其说是js把css和html阻塞了，倒不如说是js引擎抢走了渲染引擎的控制权

   * js的三种加载方式

      * 正常模式

         * <script src="index.js"></script>

         * js会阻塞页面渲染，必须等index.js加载和执行完才能去做其他事情

      * async模式

         * <script async src="index.js"></script>

         * js加载不会阻塞浏览器做任何其他事情。
他的加载是异步的
当加载结束，js脚本会立即执行，执行会阻塞渲染。

      * defer模式

         * <script defer src="index.js"></script>

         * js的加载是异步的

         * 执行是被推迟的

         * 等整个文档解析完成，DOMContentLoaded事件即将被触发时，js文件才会开始执行

      * 当脚本与dom没有依赖时，选用async
脚本依赖于dom时，选用defer

### dom优化

#### dom为什么慢

##### js去操作dom时，本质上是js引擎和渲染引擎之间进行了“跨界交流”

###### 

##### 对dom的修改会引发它外观（样式）上的改变时，就会触发回流或重绘

###### 

##### 回流

###### 对dom的修改引发了dom几何尺寸的变化（如宽、高）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来

##### 重绘

###### 对dom修改导致了样式变化，却没有影响几何属性（如背景色或颜色）时，浏览器不需要重新计算元素的几何属性，直接为该元素绘制新的样式。（跳过了图中的回流环节）

### Event Loop（事件循环）与异步更新策略

#### 事件循环

##### 宏任务

###### 常见类型

   * setTimeout

   * setInterval

   * dom事件

   * i/o操作

   * ui渲染

   * script(整体代码)

##### 微任务

###### 常见类型

   * Promise

   * process.nextTick

##### 事件循环过程

###### 初始状态

   * 调用栈空，微任务队列空，宏任务队列里有且只有一个script脚本

###### script被推入调用栈

   * 代码同步执行，在执行过程中，可以产生新的宏任务和微任务，它们会分别被推入各自的任务队列

   * 同步代码执行完，script被移出宏队列

      * 这个过程本质上是队列的宏任务的执行和出队的过程

###### 处理微队列

   * 会逐个执行队列中的任务并把它出队，直到队列被清空

###### 执行渲染操作，更新界面

###### 检查是否存在web worker任务，如果有，则对其进行处理

###### 全过程

   * 

##### 宏任务出队时，是一个一个执行的
微任务出队时，是一队一队执行的

###### 

##### 如何优化

###### 异步执行多个dom操作时，把dom操作放入微任务队列里，一次执行完

### 回流与重绘

#### 回流

##### 获取一些特定属性的值，也会触发回流
因为它们需要通过即时计算得到

###### offsetTop、offsetLeft、offsetWidth、scrollTop、clientTop等

###### 获取属性时最好用变量存下来

##### 优化

###### 避免逐条改变样式，可用类去合并样式，修改一次

   * 或者将dom离线化：
设display:none后
再逐条改变样式
再设display为原值

## 应用篇

### 懒加载

#### 页面打开时只把首屏的图片资源加载出来
下面的图片等用户下拉的瞬间再即时去请求

#### 还没来得及被图片填充完全的网页，可以用div元素先占位

#### 实现

##### 两个关键数值

###### 当前可视区域的高度

###### 元素距离可视区域顶部的高度

### 节流与防抖

#### 都以闭包的形式存在

#### 节流

##### 在某段时间内，无论触发了多少回调，只认第一次
并在计时结束给于响应

###### 在一段时间内，无视后来产生的回调请求

#### 防抖

##### 在某段时间内，无论触发了多少回调，只认最后一次

#### 用节流来优化防抖

##### delay时间内，可以重新生成定时器，但只要delay时间到了，就必须给用户一个响应
